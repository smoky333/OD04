#O(log n) при хорошем разделении и O(n) в худшем случае из-за рекурсии.
#Эффективен для сортировки списков, но может быть не лучшим выбором для больших массивов,
#если разделение неравномерно.


def quick_sort(s):
    if len(s) <= 1:
        return s  # Если длина списка <= 1, он уже отсортирован.
    element = s[0]  # Элемент, относительно которого будет разделение.
    left = list(filter(lambda x: x < element, s[1:]))  # Все элементы меньше разделителя.
    center = [i for i in s if i == element]  # Все элементы, равные разделителю.
    right = list(filter(lambda x: x > element, s[1:]))  # Все элементы больше разделителя.

    return quick_sort(left) + center + quick_sort(right)  # Рекурсивный вызов для подмассивов.
